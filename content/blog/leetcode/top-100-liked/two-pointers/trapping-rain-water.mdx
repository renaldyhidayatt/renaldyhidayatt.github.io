---
title: Trapping Rain Water
description: Implementation of the Trapping Rain Water algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given `n` non-negative integers representing an elevation map where the width of each bar is `1`, compute how much water it can trap after raining.

### Example 1:

**Input:**
```
height = [0,1,0,2,1,0,1,3,2,1,2,1]
```
**Output:**
```
6
```

### Example 2:

**Input:**
```
height = [4,2,0,3,2,5]
```
**Output:**
```
9
```

## Approach

Use two-pointer or dynamic programming techniques to compute the trapped water efficiently.

## Algorithm

1. Use two pointers (`left` and `right`) initialized at the ends of the array.
2. Maintain `leftMax` and `rightMax` to keep track of the maximum heights encountered.
3. Calculate trapped water at each step by comparing `leftMax` and `rightMax`.

## Implementations

### Implementation in Go

```go
package main

import "fmt"

func trap(height []int) int {
    if len(height) == 0 {
        return 0
    }
    left, right := 0, len(height)-1
    leftMax, rightMax := 0, 0
    water := 0

    for left < right {
        if height[left] < height[right] {
            if height[left] >= leftMax {
                leftMax = height[left]
            } else {
                water += leftMax - height[left]
            }
            left++
        } else {
            if height[right] >= rightMax {
                rightMax = height[right]
            } else {
                water += rightMax - height[right]
            }
            right--
        }
    }
    return water
}

func main() {
    height := []int{0,1,0,2,1,0,1,3,2,1,2,1}
    fmt.Println(trap(height))
}
```

### Implementation in Java

```java
class Solution {
    public int trap(int[] height) {
        if (height.length == 0) return 0;
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0, water = 0;

        while (left < right) {
            if (height[left] < height[right]) {
                if (height[left] >= leftMax) {
                    leftMax = height[left];
                } else {
                    water += leftMax - height[left];
                }
                left++;
            } else {
                if (height[right] >= rightMax) {
                    rightMax = height[right];
                } else {
                    water += rightMax - height[right];
                }
                right--;
            }
        }
        return water;
    }
    
    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] height = {0,1,0,2,1,0,1,3,2,1,2,1};
        System.out.println(solution.trap(height));
    }
}
```

### Implementation in Python

```python
from typing import List

class Solution:
    def trap(self, height: List[int]) -> int:
        if not height:
            return 0
        
        left, right = 0, len(height) - 1
        left_max = right_max = water = 0
        
        while left < right:
            if height[left] < height[right]:
                if height[left] >= left_max:
                    left_max = height[left]
                else:
                    water += left_max - height[left]
                left += 1
            else:
                if height[right] >= right_max:
                    right_max = height[right]
                else:
                    water += right_max - height[right]
                right -= 1
        
        return water

# Contoh penggunaan
if __name__ == "__main__":
    solution = Solution()
    height = [0,1,0,2,1,0,1,3,2,1,2,1]
    print(solution.trap(height))  # Output: 6
```

## Explanation

- **Two Pointers:** Reduces space complexity by avoiding additional arrays.
- **Max Height Tracking:** Ensures efficient computation of trapped water.

## Time and Space Complexity

- **Time Complexity:** `O(n)`, since each element is processed once.
- **Space Complexity:** `O(1)`, using only constant extra space.

## Conclusion

The **Trapping Rain Water** problem is efficiently solved using the two-pointer technique, reducing both time and space complexity. ðŸš€

