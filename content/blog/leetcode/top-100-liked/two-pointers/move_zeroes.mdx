---
title: Move Zeroes
description: Move all zeroes in an array to the end while maintaining the relative order of non-zero elements. Includes Go and Java implementations.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-02"
published: false
---

## Table of Contents
1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given an integer array `nums`, move all `0`'s to the end of it while maintaining the relative order of the non-zero elements.

**Note**: You must do this in-place without making a copy of the array.

### Example 1:

**Input:**
```plaintext
nums = [0,1,0,3,12]
```
**Output:**
```plaintext
[1,3,12,0,0]
```

### Example 2:

**Input:**
```plaintext
nums = [0]
```
**Output:**
```plaintext
[0]
```

### Constraints:

- `1 <= nums.length <= 10^4`
- `-2^31 <= nums[i] <= 2^31 - 1`

**Follow-up:** Can you minimize the total number of operations done?

## Approach

We can use a two-pointer approach to move all zeroes to the end while maintaining the order of non-zero elements efficiently.

### Algorithm

1. Initialize a pointer `nonZeroIndex = 0`.
2. Iterate through the array:
   - If `nums[i]` is non-zero, swap `nums[i]` with `nums[nonZeroIndex]` and increment `nonZeroIndex`.
3. After the loop, all zeroes will be moved to the end.

## Flowchart

_(Flowchart will be added here to visualize the process.)_

## Implementations

### Implementation in Go

```go
func moveZeroes(nums []int) {
    nonZeroIndex := 0
    for i := 0; i < len(nums); i++ {
        if nums[i] != 0 {
            nums[i], nums[nonZeroIndex] = nums[nonZeroIndex], nums[i]
            nonZeroIndex++
        }
    }
}
```

### Implementation in Java

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int nonZeroIndex = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                int temp = nums[i];
                nums[i] = nums[nonZeroIndex];
                nums[nonZeroIndex] = temp;
                nonZeroIndex++;
            }
        }
    }
}
```

## Explanation

The approach ensures that we iterate over the array only once (`O(n)`) while maintaining the relative order of non-zero elements. We use a single pointer to track the position where the next non-zero element should be placed.

## Time and Space Complexity

- **Time Complexity:** `O(n)` - We traverse the array once.
- **Space Complexity:** `O(1)` - We modify the input array in-place.

## Conclusion

By using the two-pointer approach, we efficiently move zeroes to the end of the array while preserving the order of non-zero elements. This method minimizes the number of operations and ensures an optimal solution.

