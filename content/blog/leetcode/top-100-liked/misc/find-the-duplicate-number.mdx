---
title: Find the Duplicate Number
description: Implementation of the Find the Duplicate Number algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
----------------

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given an array of integers `nums` containing `n + 1` integers where each integer is in the range `[1, n]` inclusive.

There is only one repeated number in `nums`, return this repeated number.

You must solve the problem without modifying the array `nums` and using only constant extra space.

### Example 1:

**Input:**
```
nums = [1,3,4,2,2]
```
**Output:**
```
2
```

### Example 2:

**Input:**
```
nums = [3,1,3,4,2]
```
**Output:**
```
3
```

### Example 3:

**Input:**
```
nums = [3,3,3,3,3]
```
**Output:**
```
3
```

## Approach

- **Floydâ€™s Tortoise and Hare Algorithm:**
  - Uses cycle detection to find the duplicate number.
  - Works in `O(n)` time complexity with `O(1)` space.

## Algorithm

1. Use two pointers: slow and fast.
2. Move slow by one step, fast by two steps.
3. When they meet, start another pointer from the beginning.
4. Move both pointers at the same speed until they meet again.

## Implementations

### Implementation in Go

```go
package main
import "fmt"

func findDuplicate(nums []int) int {
    slow, fast := nums[0], nums[nums[0]]
    for slow != fast {
        slow = nums[slow]
        fast = nums[nums[fast]]
    }
    slow = 0
    for slow != fast {
        slow = nums[slow]
        fast = nums[fast]
    }
    return slow
}

func main() {
    nums := []int{1,3,4,2,2}
    fmt.Println(findDuplicate(nums)) // Output: 2
}
```

### Implementation in Java

```java
class FindDuplicate {
    public int findDuplicate(int[] nums) {
        int slow = nums[0], fast = nums[nums[0]];
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[nums[fast]];
        }
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }

    public static void main(String[] args) {
        FindDuplicate fd = new FindDuplicate();
        int[] nums = {1,3,4,2,2};
        System.out.println(fd.findDuplicate(nums)); // Output: 2
    }
}
```

## Explanation

- **Cycle Detection Method:** Treats the array as a linked list with a cycle.
- **Tortoise and Hare Approach:** Efficient in `O(n)` time and `O(1)` space.

## Time and Space Complexity

- **Time Complexity:** `O(n)`, as we iterate through the array.
- **Space Complexity:** `O(1)`, using only two pointers.

## Conclusion

The **Find the Duplicate Number** problem can be solved efficiently using **Floydâ€™s Tortoise and Hare Algorithm**, achieving `O(n)` time complexity with `O(1)` space. ðŸš€

