---
title: Majority Element
description: Implementation of the Majority Element algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
----------------

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given an array `nums` of size `n`, return the **majority element**.

The majority element is the element that appears more than `âŒŠn / 2âŒ‹` times. You may assume that the majority element always exists in the array.

### Example 1:

**Input:**
```
nums = [3,2,3]
```
**Output:**
```
3
```

### Example 2:

**Input:**
```
nums = [2,2,1,1,1,2,2]
```
**Output:**
```
2
```

## Approach

- **Boyer-Moore Voting Algorithm:**
  - Maintains a candidate element and a count.
  - Iterates through the array, increasing or decreasing the count accordingly.
  - The final candidate is the majority element.

## Algorithm

1. Initialize `count = 0` and `candidate = None`.
2. Iterate through `nums`:
   - If `count == 0`, set `candidate = nums[i]`.
   - If `nums[i] == candidate`, increment `count`.
   - Else, decrement `count`.
3. Return `candidate`.

## Implementations

### Implementation in Go

```go
package main
import "fmt"

func majorityElement(nums []int) int {
    count, candidate := 0, 0
    for _, num := range nums {
        if count == 0 {
            candidate = num
        }
        if num == candidate {
            count++
        } else {
            count--
        }
    }
    return candidate
}

func main() {
    nums := []int{2, 2, 1, 1, 1, 2, 2}
    fmt.Println(majorityElement(nums)) // Output: 2
}
```

### Implementation in Java

```java
class MajorityElement {
    public int majorityElement(int[] nums) {
        int count = 0, candidate = 0;
        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1 : -1;
        }
        return candidate;
    }

    public static void main(String[] args) {
        MajorityElement me = new MajorityElement();
        int[] nums = {2, 2, 1, 1, 1, 2, 2};
        System.out.println(me.majorityElement(nums)); // Output: 2
    }
}
```

## Explanation

- **Boyer-Moore Voting Algorithm:** Efficiently finds the majority element in `O(n)` time.
- **Constant Space:** Uses only two variables (`count` and `candidate`).
- **Guaranteed Majority:** Since the majority element appears more than `n/2` times, it will always be found.

## Time and Space Complexity

- **Time Complexity:** `O(n)`, as we iterate through the array once.
- **Space Complexity:** `O(1)`, since we use only two variables.

## Conclusion

The **Majority Element** problem is efficiently solved using the **Boyer-Moore Voting Algorithm**, achieving `O(n)` time and `O(1)` space complexity. ðŸš€

