---
title: Sort Colors
description: Implementation of the Sort Colors algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
----------------

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given an array `nums` with `n` objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.

We will use the integers `0`, `1`, and `2` to represent the color red, white, and blue, respectively.

You must solve this problem without using the library's sort function.

### Example 1:

**Input:**
```
nums = [2,0,2,1,1,0]
```
**Output:**
```
[0,0,1,1,2,2]
```

### Example 2:

**Input:**
```
nums = [2,0,1]
```
**Output:**
```
[0,1,2]
```

## Approach

- **Dutch National Flag Algorithm:**
  - Use three pointers: `left`, `right`, and `current`.
  - `left` points to the boundary of `0`s.
  - `right` points to the boundary of `2`s.
  - Iterate through the array and swap elements accordingly.

## Algorithm

1. Initialize `left = 0`, `right = n - 1`, `current = 0`.
2. Iterate while `current <= right`:
   - If `nums[current] == 0`, swap `nums[left]` and `nums[current]`, increment `left` and `current`.
   - If `nums[current] == 2`, swap `nums[right]` and `nums[current]`, decrement `right`.
   - Otherwise, increment `current`.
3. The array will be sorted in-place.

## Implementations

### Implementation in Go

```go
package main
import "fmt"

func sortColors(nums []int) {
    left, right, current := 0, len(nums)-1, 0
    
    for current <= right {
        if nums[current] == 0 {
            nums[left], nums[current] = nums[current], nums[left]
            left++
            current++
        } else if nums[current] == 2 {
            nums[right], nums[current] = nums[current], nums[right]
            right--
        } else {
            current++
        }
    }
}

func main() {
    nums := []int{2, 0, 2, 1, 1, 0}
    sortColors(nums)
    fmt.Println(nums) // Output: [0,0,1,1,2,2]
}
```

### Implementation in Java

```java
import java.util.Arrays;

class SortColors {
    public void sortColors(int[] nums) {
        int left = 0, right = nums.length - 1, current = 0;
        
        while (current <= right) {
            if (nums[current] == 0) {
                swap(nums, left++, current++);
            } else if (nums[current] == 2) {
                swap(nums, right--, current);
            } else {
                current++;
            }
        }
    }
    
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
    public static void main(String[] args) {
        SortColors sc = new SortColors();
        int[] nums = {2, 0, 2, 1, 1, 0};
        sc.sortColors(nums);
        System.out.println(Arrays.toString(nums)); // Output: [0,0,1,1,2,2]
    }
}
```

## Explanation

- **Using Three Pointers:** Ensures a single pass sorting mechanism.
- **Efficient In-Place Sorting:** Uses constant extra space.
- **Optimal Performance:** Runs in `O(n)` time.

## Time and Space Complexity

- **Time Complexity:** `O(n)`, as we iterate the array once.
- **Space Complexity:** `O(1)`, since sorting is done in-place.

## Conclusion

The **Sort Colors** problem is efficiently solved using the Dutch National Flag algorithm, achieving an optimal `O(n)` solution. ðŸš€

