---
title: Convert Sorted Array to Binary Search Tree
description: Implementation of the Convert Sorted Array to Binary Search Tree algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given an integer array `nums` where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.

### Example 1:

**Input:**
```
nums = [-10,-3,0,5,9]
```
**Output:**
```
[0,-3,9,-10,null,5]
```

### Example 2:

**Input:**
```
nums = [1,3]
```
**Output:**
```
[3,1]
```

### Constraints:

- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` is sorted in a strictly increasing order.

## Approach

We use a recursive approach by selecting the middle element as the root, then recursively constructing left and right subtrees from the left and right halves of the array.

## Algorithm

1. If `nums` is empty, return `nil`.
2. Find the middle index of `nums`.
3. Create a new tree node with the middle value as root.
4. Recursively construct left and right subtrees using left and right halves of `nums`.

## Implementations

### Implementation in Go

```go
package main

import "fmt"

type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func sortedArrayToBST(nums []int) *TreeNode {
    if len(nums) == 0 {
        return nil
    }
    mid := len(nums) / 2
    root := &TreeNode{Val: nums[mid]}
    root.Left = sortedArrayToBST(nums[:mid])
    root.Right = sortedArrayToBST(nums[mid+1:])
    return root
}
```

### Implementation in Java

```java
class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int x) { val = x; }
}

class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        return helper(nums, 0, nums.length - 1);
    }

    private TreeNode helper(int[] nums, int left, int right) {
        if (left > right) return null;
        int mid = left + (right - left) / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = helper(nums, left, mid - 1);
        root.right = helper(nums, mid + 1, right);
        return root;
    }
}
```

### Implementation in Python

```python
from typing import List, Optional

class TreeNode:
    def __init__(self, val: int = 0, left: Optional['TreeNode'] = None, right: Optional['TreeNode'] = None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def sortedArrayToBST(self, nums: List[int]) -> Optional[TreeNode]:
        def helper(left: int, right: int) -> Optional[TreeNode]:
            if left > right:
                return None
            mid = (left + right) // 2
            root = TreeNode(nums[mid])
            root.left = helper(left, mid - 1)
            root.right = helper(mid + 1, right)
            return root
        
        return helper(0, len(nums) - 1)
```


## Explanation

Both implementations recursively build the tree using the middle element as the root to ensure balance.

## Time and Space Complexity

- **Time Complexity:** `O(n)`, as each element is processed once.
- **Space Complexity:** `O(n)`, due to recursive calls and additional tree node storage.

## Conclusion

The **Convert Sorted Array to Binary Search Tree** problem is efficiently solved using a recursive approach to ensure a height-balanced BST. ðŸš€

