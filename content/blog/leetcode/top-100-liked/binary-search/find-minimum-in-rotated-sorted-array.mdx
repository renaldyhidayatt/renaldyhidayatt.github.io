---
title: Find Minimum in Rotated Sorted Array 
description: Implementation of the Find Minimum in Rotated Sorted Array algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Suppose an array of length `n` sorted in ascending order is rotated between `1` and `n` times. Given the rotated sorted array, find the minimum element.

### Example 1:

**Input:**

```
nums = [3,4,5,1,2]
```

**Output:**

```
1
```

### Example 2:

**Input:**

```
nums = [4,5,6,7,0,1,2]
```

**Output:**

```
0
```

### Example 3:

**Input:**

```
nums = [11,13,15,17]
```

**Output:**

```
11
```

### Constraints:

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- All integers in `nums` are unique.
- `nums` is sorted in ascending order and rotated at some pivot.

## Approach

We can solve this problem using **binary search**:

1. Identify the **midpoint** of the array.
2. If `mid` is greater than the **last element**, the minimum is in the **right half**.
3. Otherwise, the minimum is in the **left half**.
4. Continue searching until the left and right pointers converge.

## Algorithm

1. Initialize `left = 0` and `right = len(nums) - 1`.
2. While `left < right`:
   - Find `mid = left + (right - left) / 2`.
   - If `nums[mid] > nums[right]`, search in the right half.
   - Otherwise, search in the left half.
3. Return `nums[left]` as the minimum element.

## Implementations

### Implementation in Go

```go
package main

import "fmt"

func findMin(nums []int) int {
    left, right := 0, len(nums)-1
    
    for left < right {
        mid := left + (right-left)/2
        if nums[mid] > nums[right] {
            left = mid + 1
        } else {
            right = mid
        }
    }
    return nums[left]
}

func main() {
    nums := []int{3,4,5,1,2}
    fmt.Println(findMin(nums)) // Output: 1
}
```

### Implementation in Java

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0, right = nums.length - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > nums[right]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return nums[left];
    }
    
    public static void main(String[] args) {
        Solution sol = new Solution();
        int[] nums = {4,5,6,7,0,1,2};
        System.out.println(sol.findMin(nums)); // Output: 0
    }
}
```

## Explanation

- The binary search technique ensures logarithmic time complexity.
- We always eliminate half of the search space in each iteration.
- The left pointer eventually points to the minimum element.

## Time and Space Complexity

- **Time Complexity:** `O(log n)`, since we perform binary search.
- **Space Complexity:** `O(1)`, as we use only constant extra space.

## Conclusion

The **Find Minimum in Rotated Sorted Array** problem is efficiently solved using **binary search**. This ensures a fast and optimized approach. ðŸš€

