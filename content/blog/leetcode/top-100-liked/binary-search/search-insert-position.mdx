---
title: Search Insert Position
description: Implementation of the Search Insert Position algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You must write an algorithm with `O(log n)` runtime complexity.

### Example 1:

**Input:**
```
nums = [1,3,5,6], target = 5
```
**Output:**
```
2
```

### Example 2:

**Input:**
```
nums = [1,3,5,6], target = 2
```
**Output:**
```
1
```

### Example 3:

**Input:**
```
nums = [1,3,5,6], target = 7
```
**Output:**
```
4
```

### Constraints:

- `1 <= nums.length <= 10^4`
- `-10^4 <= nums[i] <= 10^4`
- `nums` contains distinct values sorted in ascending order.
- `-10^4 <= target <= 10^4`

## Approach

We use **binary search** to efficiently find the target or determine its correct insert position:

1. Initialize `left = 0` and `right = len(nums) - 1`.
2. Perform binary search:
   - If `nums[mid] == target`, return `mid`.
   - If `nums[mid] < target`, move `left` to `mid + 1`.
   - Else, move `right` to `mid - 1`.
3. When `left` surpasses `right`, return `left` as the insertion index.

## Algorithm

1. Initialize `left = 0`, `right = len(nums) - 1`.
2. Use binary search to find the position:
   - If `nums[mid]` equals `target`, return `mid`.
   - If `nums[mid]` is less than `target`, update `left = mid + 1`.
   - Else, update `right = mid - 1`.
3. Return `left` as the insertion index.

## Implementations

### Implementation in Go

```go
package main

import "fmt"

func searchInsert(nums []int, target int) int {
    left, right := 0, len(nums)-1
    for left <= right {
        mid := left + (right-left)/2
        if nums[mid] == target {
            return mid
        } else if nums[mid] < target {
            left = mid + 1
        } else {
            right = mid - 1
        }
    }
    return left
}

func main() {
    nums := []int{1,3,5,6}
    target := 5
    fmt.Println(searchInsert(nums, target)) // Output: 2
}
```

### Implementation in Java

```java
class SearchInsertPosition {
    public int searchInsert(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }

    public static void main(String[] args) {
        SearchInsertPosition solution = new SearchInsertPosition();
        int[] nums = {1,3,5,6};
        int target = 5;
        System.out.println(solution.searchInsert(nums, target)); // Output: 2
    }
}
```

### Implementation in Python

```python
class Solution:
    def searchInsert(self, nums: list[int], target: int) -> int:
        left, right = 0, len(nums) - 1
        
        while left <= right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] < target:
                left = mid + 1
            else:
                right = mid - 1
        
        return left

# Contoh penggunaan
if __name__ == "__main__":
    solution = Solution()
    nums = [1, 3, 5, 6]
    target = 5
    print(solution.searchInsert(nums, target))  # Output: 2

```

## Explanation

Both implementations utilize **binary search** to efficiently find the target's position or determine where it should be inserted.

## Time and Space Complexity

- **Time Complexity:** `O(log n)`, since binary search reduces the search space by half in each iteration.
- **Space Complexity:** `O(1)`, as no additional space is required.

## Conclusion

The **Search Insert Position** problem is efficiently solved using a **binary search** approach, ensuring an `O(log n)` runtime complexity. ðŸš€

