---
title: Search a 2D Matrix II
description: Implementation of the Search a 2D Matrix II algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Write an efficient algorithm that searches for a value `target` in an `m x n` integer matrix. This matrix has the following properties:

- Integers in each row are sorted in ascending order from left to right.
- Integers in each column are sorted in ascending order from top to bottom.

### Example 1:

**Input:**
```
matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]]
target = 5
```
**Output:**
```
true
```

### Example 2:

**Input:**
```
matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]]
target = 20
```
**Output:**
```
false
```

## Approach

We start searching from the **top-right corner** of the matrix and use a **binary search-like** approach:

1. If the current element is equal to the target, return `true`.
2. If the current element is greater than the target, move left.
3. If the current element is smaller than the target, move down.
4. Repeat until we either find the target or go out of bounds.

## Algorithm

1. Start from the top-right corner of the matrix `(0, cols-1)`.
2. Compare the element with the target.
3. If it matches, return `true`.
4. If it is greater than the target, move left (decrease column index).
5. If it is smaller than the target, move down (increase row index).
6. Continue until the indices go out of bounds.

## Implementations

### Implementation in Go

```go
package main

func searchMatrix(matrix [][]int, target int) bool {
    if len(matrix) == 0 || len(matrix[0]) == 0 {
        return false
    }

    rows, cols := len(matrix), len(matrix[0])
    row, col := 0, cols-1 

    for row < rows && col >= 0 { 
        if matrix[row][col] == target {
            return true
        } else if matrix[row][col] > target {
            col-- 
        } else {
            row++ 
        }
    }
    
    return false
}
```

### Implementation in Java

```java
class SearchMatrix2D {
    public boolean searchMatrix(int[][] matrix, int target) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return false;
        }
        
        int rows = matrix.length, cols = matrix[0].length;
        int row = 0, col = cols - 1;
        
        while (row < rows && col >= 0) {
            if (matrix[row][col] == target) {
                return true;
            } else if (matrix[row][col] > target) {
                col--;
            } else {
                row++;
            }
        }
        
        return false;
    }
}
```

### Implementation in Python

```python
class SearchMatrix2D:
    def searchMatrix(self, matrix, target):
        if not matrix or not matrix[0]:
            return False
        
        rows, cols = len(matrix), len(matrix[0])
        row, col = 0, cols - 1
        
        while row < rows and col >= 0:
            if matrix[row][col] == target:
                return True
            elif matrix[row][col] > target:
                col -= 1
            else:
                row += 1
        
        return False
```


## Explanation

- **Step 1:** Start from the top-right corner.
- **Step 2:** Move left if the current element is greater than the target.
- **Step 3:** Move down if the current element is smaller than the target.
- **Step 4:** Repeat until the target is found or the indices go out of bounds.

## Time and Space Complexity

- **Time Complexity:** `O(m + n)`, since in the worst case, we traverse `m + n` elements.
- **Space Complexity:** `O(1)`, since we only use a few extra variables.

## Conclusion

The **Search a 2D Matrix II** problem is efficiently solved using a **greedy search approach** from the top-right corner, achieving `O(m + n)` time complexity with `O(1)` space complexity. ðŸš€

