---
title: Best Time to Buy and Sell Stock
description: Implementation of the Best Time to Buy and Sell Stock algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

You are given an array `prices` where `prices[i]` is the price of a given stock on the `i`th day.

You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.

Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return `0`.

### Example 1:

**Input:**
```
prices = [7,1,5,3,6,4]
```
**Output:**
```
5
```
**Explanation:** Buy on day `2` (price = `1`) and sell on day `5` (price = `6`), profit = `6-1 = 5`.

### Example 2:

**Input:**
```
prices = [7,6,4,3,1]
```
**Output:**
```
0
```
**Explanation:** No transactions are done, so the max profit = `0`.

### Constraints:

- `1 <= prices.length <= 10^5`
- `0 <= prices[i] <= 10^4`

## Approach

We use a **greedy approach** to keep track of the minimum price seen so far and calculate the maximum profit.

## Algorithm

1. Initialize `minPrice = prices[0]` and `maxProfit = 0`.
2. Iterate through `prices`:
   - If `prices[i] < minPrice`, update `minPrice`.
   - Otherwise, update `maxProfit` with `prices[i] - minPrice`.
3. Return `maxProfit`.

## Implementations

### Implementation in Go

```go
package main

import "fmt"

func maxProfit(prices []int) int {
    minPrice := prices[0]
    maxProfit := 0
    
    for _, price := range prices {
        if price < minPrice {
            minPrice = price
        } else {
            maxProfit = max(maxProfit, price - minPrice)
        }
    }
    return maxProfit
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    prices := []int{7,1,5,3,6,4}
    fmt.Println(maxProfit(prices)) // Output: 5
}
```

### Implementation in Java

```java
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = Integer.MAX_VALUE;
        int maxProfit = 0;
        
        for (int price : prices) {
            if (price < minPrice) {
                minPrice = price;
            } else {
                maxProfit = Math.max(maxProfit, price - minPrice);
            }
        }
        return maxProfit;
    }
}
```

## Explanation

- **Greedy approach** ensures we track the lowest price and the highest possible profit.
- If we ever find a price lower than `minPrice`, we update it.
- If the difference between the current price and `minPrice` is greater than `maxProfit`, we update `maxProfit`.

## Time and Space Complexity

- **Time Complexity:** `O(n)`, since we traverse the array once.
- **Space Complexity:** `O(1)`, as no extra space is used.

## Conclusion

The **Best Time to Buy and Sell Stock** problem can be efficiently solved using a **greedy approach** to track the minimum price and maximize the profit. ðŸš€

