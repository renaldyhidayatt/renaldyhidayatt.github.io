---
title: Jump Game
description: Implementation of the Jump Game algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

You are given an integer array `nums`. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.

Return `true` if you can reach the last index, or `false` otherwise.

### Example 1:

**Input:**
```
nums = [2,3,1,1,4]
```
**Output:**
```
true
```
**Explanation:** Jump 1 step from index `0` to `1`, then `3` steps to the last index.

### Example 2:

**Input:**
```
nums = [3,2,1,0,4]
```
**Output:**
```
false
```
**Explanation:** You will always arrive at index `3` no matter what. Its maximum jump length is `0`, which makes it impossible to reach the last index.

### Constraints:

- `1 <= nums.length <= 10^4`
- `0 <= nums[i] <= 10^5`

## Approach

We use a **greedy approach** to track the farthest index we can reach. If at any point we cannot proceed further, we return `false`.

## Algorithm

1. Initialize `maxReach = 0`.
2. Iterate through `nums`, updating `maxReach`.
3. If `maxReach` reaches the last index, return `true`.
4. If at any point `i > maxReach`, return `false`.

## Implementations

### Implementation in Go

```go
package main

import "fmt"

func canJump(nums []int) bool {
    maxReach := 0
    for i, num := range nums {
        if i > maxReach {
            return false
        }
        maxReach = max(maxReach, i+num)
    }
    return true
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}

func main() {
    nums := []int{2, 3, 1, 1, 4}
    fmt.Println(canJump(nums)) // Output: true
}
```

### Implementation in Java

```java
class Solution {
    public boolean canJump(int[] nums) {
        int maxReach = 0;
        for (int i = 0; i < nums.length; i++) {
            if (i > maxReach) {
                return false;
            }
            maxReach = Math.max(maxReach, i + nums[i]);
        }
        return true;
    }
}
```

## Explanation

- **Greedy approach** ensures that we track the farthest reachable index.
- If we ever reach a point where `i > maxReach`, we return `false`.
- **O(n) complexity** ensures efficiency for large inputs.

## Time and Space Complexity

- **Time Complexity:** `O(n)`, since we traverse the array once.
- **Space Complexity:** `O(1)`, as no extra space is used.

## Conclusion

The **Jump Game** problem can be efficiently solved using a **greedy approach** to determine if we can reach the last index. ðŸš€

