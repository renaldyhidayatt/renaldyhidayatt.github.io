---
title: Generate Parentheses
description: Implementation of the Generate Parentheses algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given `n` pairs of parentheses, write a function to generate all combinations of well-formed parentheses.

### Example 1:

**Input:** `n = 3`

**Output:** `["((()))","(()())","(())()","()(())","()()()"]`

### Example 2:

**Input:** `n = 1`

**Output:** `["()"]`

### Constraints:

- `1 <= n <= 8`

## Approach

We can solve this problem using **backtracking**. The idea is to generate all possible valid combinations of parentheses by ensuring that we only add a closing parenthesis when there are more open parentheses in use.

## Algorithm

1. Use a helper function `backtrack` that takes three parameters: `current` (the current string of parentheses), `open` (count of open parentheses used), and `close` (count of close parentheses used).
2. If the length of `current` equals `2 * n`, we add it to the result list.
3. If `open < n`, we add an open parenthesis and recurse.
4. If `close < open`, we add a close parenthesis and recurse.

## Implementations

### Implementation in Go

```go
package main

import (
	"fmt"
)

func generateParenthesis(n int) []string {
	var result []string
	var backtrack func(string, int, int)

	backtrack = func(current string, open int, close int) {
		if len(current) == 2*n {
			result = append(result, current)
			return
		}
		if open < n {
			backtrack(current+"(", open+1, close)
		}
		if close < open {
			backtrack(current+")", open, close+1)
		}
	}

	backtrack("", 0, 0)
	return result
}

func main() {
	n := 3
	fmt.Println(generateParenthesis(n))
}
```

### Implementation in Java

```java
import java.util.*;

public class GenerateParentheses {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        backtrack(result, "", 0, 0, n);
        return result;
    }

    private void backtrack(List<String> result, String current, int open, int close, int max) {
        if (current.length() == max * 2) {
            result.add(current);
            return;
        }
        if (open < max) {
            backtrack(result, current + "(", open + 1, close, max);
        }
        if (close < open) {
            backtrack(result, current + ")", open, close + 1, max);
        }
    }

    public static void main(String[] args) {
        GenerateParentheses gp = new GenerateParentheses();
        System.out.println(gp.generateParenthesis(3));
    }
}
```

## Explanation

The recursive function ensures that only valid sequences of parentheses are generated by limiting the addition of closing parentheses based on the number of opening parentheses used. This avoids generating invalid sequences and reduces unnecessary computations.

## Time and Space Complexity

- **Time Complexity:** `O(4^n / sqrt(n))`, since we generate **Catalan numbers** of order `n`.
- **Space Complexity:** `O(4^n / sqrt(n))` due to recursion and result storage.

## Conclusion

The backtracking approach efficiently generates all possible valid parentheses sequences while ensuring correctness. Both the Go and Java implementations follow the same logic and generate the required output efficiently.