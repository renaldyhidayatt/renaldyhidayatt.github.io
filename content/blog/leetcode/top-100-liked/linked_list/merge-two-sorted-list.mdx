---
title:  Merge Two Sorted Lists
description: Implementation of the Merge Two Sorted Lists algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

You are given the heads of two sorted linked lists `list1` and `list2`.

Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

### Example 1:

**Input:**
```  
list1 = [1,2,4], list2 = [1,3,4]  
```
**Output:**
```  
[1,1,2,3,4,4]  
```

### Example 2:

**Input:**
```  
list1 = [], list2 = []  
```
**Output:**
```  
[]  
```

### Example 3:

**Input:**
```  
list1 = [], list2 = [0]  
```
**Output:**
```  
[0]  
```

### Constraints:

- The number of nodes in both lists is in the range `[0, 50]`.
- `-100 <= Node.val <= 100`
- Both `list1` and `list2` are sorted in non-decreasing order.

## Approach

We use a **dummy node** and **two pointers** to merge both lists efficiently.

## Algorithm

1. Create a dummy node as the starting point.
2. Use two pointers to traverse `list1` and `list2`.
3. Compare values at each step and append the smaller node to the merged list.
4. If one list is exhausted, append the remaining nodes of the other list.
5. Return `dummy.next` as the merged list's head.

## Implementations

### Implementation in Go

```go
package main

type ListNode struct {
    Val  int
    Next *ListNode
}

func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
    dummy := &ListNode{}
    current := dummy
    
    for list1 != nil && list2 != nil {
        if list1.Val < list2.Val {
            current.Next = list1
            list1 = list1.Next
        } else {
            current.Next = list2
            list2 = list2.Next
        }
        current = current.Next
    }
    
    if list1 != nil {
        current.Next = list1
    } else {
        current.Next = list2
    }
    
    return dummy.Next
}
```

### Implementation in Java

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(0);
        ListNode current = dummy;
        
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                current.next = list1;
                list1 = list1.next;
            } else {
                current.next = list2;
                list2 = list2.next;
            }
            current = current.next;
        }
        
        if (list1 != null) {
            current.next = list1;
        } else {
            current.next = list2;
        }
        
        return dummy.next;
    }
}
```

### Implementation in Python

```python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:
        dummy = ListNode(0)
        current = dummy
        
        while list1 is not None and list2 is not None:
            if list1.val < list2.val:
                current.next = list1
                list1 = list1.next
            else:
                current.next = list2
                list2 = list2.next
            current = current.next
        
        if list1 is not None:
            current.next = list1
        else:
            current.next = list2
        
        return dummy.next
```




## Explanation

- **Two Pointer Approach:**
  - Compare elements from both lists one by one.
  - Append the smaller element to the merged list.
  - Continue until one of the lists is exhausted, then append the remaining nodes.

## Time and Space Complexity

- **Time Complexity:** `O(n + m)`, where `n` and `m` are the lengths of the lists.
- **Space Complexity:** `O(1)`, since only pointers are used.

## Conclusion

The **Merge Two Sorted Lists** problem can be efficiently solved using a **dummy node and two-pointer technique**, ensuring `O(n + m)` complexity. ðŸš€

