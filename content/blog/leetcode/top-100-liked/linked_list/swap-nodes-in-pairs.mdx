---
title: Swap Nodes in Pairs
description: Implementation of the Swap Nodes in Pairs algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list's nodes (i.e., only nodes themselves may be changed).

### Example 1:

**Input:**
```  
head = [1,2,3,4]  
```
**Output:**
```  
[2,1,4,3]  
```

### Example 2:

**Input:**
```  
head = []  
```
**Output:**
```  
[]  
```

### Example 3:

**Input:**
```  
head = [1]  
```
**Output:**
```  
[1]  
```

### Constraints:

- The number of nodes in the list is in the range `[0, 100]`.
- `0 <= Node.val <= 100`

## Approach

We use a **dummy node** and **recursion or iterative pointer swapping** to achieve the swapping in pairs.

## Algorithm

1. Create a dummy node pointing to the head.
2. Use two pointers to swap adjacent nodes.
3. Move pointers forward in pairs.
4. Return `dummy.next` as the new head.

## Implementations

### Implementation in Go

```go
package main

type ListNode struct {
    Val  int
    Next *ListNode
}

func swapPairs(head *ListNode) *ListNode {
    dummy := &ListNode{Next: head}
    prev := dummy
    
    for head != nil && head.Next != nil {
        first := head
        second := head.Next
        
        prev.Next = second
        first.Next = second.Next
        second.Next = first
        
        prev = first
        head = first.Next
    }
    
    return dummy.Next
}
```

### Implementation in Java

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

class Solution {
    public ListNode swapPairs(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;
        
        while (head != null && head.next != null) {
            ListNode first = head;
            ListNode second = head.next;
            
            prev.next = second;
            first.next = second.next;
            second.next = first;
            
            prev = first;
            head = first.next;
        }
        
        return dummy.next;
    }
}
```

## Explanation

- **Iterative Pointer Approach:**
  - Maintain a dummy node and use two pointers.
  - Swap adjacent nodes and move forward.
  - Ensures efficient in-place swapping without modifying values.

## Time and Space Complexity

- **Time Complexity:** `O(n)`, where `n` is the number of nodes in the list.
- **Space Complexity:** `O(1)`, since swapping is done in-place.

## Conclusion

The **Swap Nodes in Pairs** problem can be efficiently solved using a **dummy node and pointer swapping technique**, ensuring `O(n)` complexity. ðŸš€

