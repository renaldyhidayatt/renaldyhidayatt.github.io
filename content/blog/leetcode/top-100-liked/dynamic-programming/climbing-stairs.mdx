---
title: Climbing Stairs
description: Implementation of the Climbing Stairs algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

You are climbing a staircase. It takes `n` steps to reach the top.

Each time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?

### Example 1:

**Input:**
```
n = 2
```
**Output:**
```
2
```
**Explanation:** There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps

### Example 2:

**Input:**
```
n = 3
```
**Output:**
```
3
```
**Explanation:** There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step

### Constraints:

- `1 <= n <= 45`

## Approach

This problem follows the **Fibonacci sequence**, where:

- `f(n) = f(n-1) + f(n-2)`
- Base cases:
  - `f(1) = 1`
  - `f(2) = 2`

We can solve it efficiently using **dynamic programming** or **iteration** to avoid unnecessary recalculations.

## Algorithm

1. Initialize two variables to store previous results: `first = 1`, `second = 2`.
2. Iterate from `3` to `n`, updating the current number of ways using `first + second`.
3. Return the final computed value.

## Implementations

### Implementation in Go

```go
package main

import "fmt"

func climbStairs(n int) int {
    if n == 1 {
        return 1
    }
    first, second := 1, 2
    for i := 3; i <= n; i++ {
        first, second = second, first+second
    }
    return second
}

func main() {
    fmt.Println(climbStairs(2)) // Output: 2
    fmt.Println(climbStairs(3)) // Output: 3
}
```

### Implementation in Java

```java
class Solution {
    public int climbStairs(int n) {
        if (n == 1) return 1;
        int first = 1, second = 2;
        for (int i = 3; i <= n; i++) {
            int temp = second;
            second = first + second;
            first = temp;
        }
        return second;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        System.out.println(sol.climbStairs(2)); // Output: 2
        System.out.println(sol.climbStairs(3)); // Output: 3
    }
}
```

## Explanation

- The solution follows **dynamic programming**, optimizing memory by only storing two previous values.
- Instead of recursion, an **iterative approach** is used for better efficiency (`O(n)` time, `O(1)` space).

## Time and Space Complexity

- **Time Complexity:** `O(n)`, since we iterate once from `1` to `n`.
- **Space Complexity:** `O(1)`, as we only use two integer variables.

## Conclusion

The **Climbing Stairs** problem is a classic **dynamic programming** problem that can be solved efficiently using an iterative approach with `O(n)` time complexity and `O(1)` space complexity. ðŸš€

