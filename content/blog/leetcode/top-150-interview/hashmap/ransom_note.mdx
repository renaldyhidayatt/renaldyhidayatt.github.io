---
title: Ransom Note
description: Implementation of the Ransom Note algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given two strings `ransomNote` and `magazine`, return `true` if `ransomNote` can be constructed using the letters from `magazine` and `false` otherwise.

Each letter in `magazine` can only be used **once** in `ransomNote`.

### Example:

**Input:**
```
ransomNote = "a", magazine = "b"
```
**Output:**
```
false
```

**Input:**
```
ransomNote = "aa", magazine = "ab"
```
**Output:**
```
false
```

**Input:**
```
ransomNote = "aa", magazine = "aab"
```
**Output:**
```
true
```

## Approach

1. Count the occurrences of each letter in `magazine`.
2. Check if `ransomNote` can be formed using the available letters.

## Algorithm

1. Create a frequency map for `magazine`.
2. Iterate through `ransomNote`, reducing counts from the map.
3. If a letter count becomes negative, return `false`.

## Implementations

### Implementation in Go

```go
package main

import "fmt"

func canConstruct(ransomNote string, magazine string) bool {
    charCount := make(map[rune]int)
    for _, ch := range magazine {
        charCount[ch]++
    }
    for _, ch := range ransomNote {
        if charCount[ch] == 0 {
            return false
        }
        charCount[ch]--
    }
    return true
}

func main() {
    fmt.Println(canConstruct("aa", "aab")) // true
}
```

### Implementation in Java

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        int[] charCount = new int[26];
        for (char c : magazine.toCharArray()) {
            charCount[c - 'a']++;
        }
        for (char c : ransomNote.toCharArray()) {
            if (charCount[c - 'a'] == 0) {
                return false;
            }
            charCount[c - 'a']--;
        }
        return true;
    }
}
```

## Explanation

- **Step 1:** Count letters in `magazine`.
- **Step 2:** Verify that `ransomNote` can be formed.
- **Step 3:** Return `true` if all letters match constraints.

## Time and Space Complexity

- **Time Complexity:** `O(m + n)`, where `m` is the length of `magazine` and `n` is the length of `ransomNote`.
- **Space Complexity:** `O(1)`, since the alphabet has a fixed size (`26`).

## Conclusion

This approach efficiently determines if a ransom note can be formed using a frequency map. ðŸš€

