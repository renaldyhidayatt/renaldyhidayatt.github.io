---
title: Contains Duplicate II
description: Implementation of the Contains Duplicate II algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given an integer array `nums` and an integer `k`, return `true` if there are two distinct indices `i` and `j` in the array such that `nums[i] == nums[j]` and `abs(i - j) <= k`.

### Example:

**Input:**

```
nums = [1,2,3,1], k = 3
```

**Output:**

```
true
```

**Input:**

```
nums = [1,0,1,1], k = 1
```

**Output:**

```
true
```

**Input:**

```
nums = [1,2,3,1,2,3], k = 2
```

**Output:**

```
false
```

## Approach

1. Use a hash map to store the last seen index of each element.
2. Iterate through the array, checking if the current element exists in the map and if the difference in indices is within `k`.
3. If the condition is met, return `true`.
4. If the loop completes without finding a match, return `false`.

## Algorithm

1. Create a hash map to store the last seen index of elements.
2. Iterate through `nums`, checking if `nums[i]` is in the map.
3. If `nums[i]` exists and `i - map[nums[i]] <= k`, return `true`.
4. Update the map with the current index of `nums[i]`.
5. Return `false` if no valid pair is found.

## Implementations

### Implementation in Go

```go
package main

import "fmt"

func containsNearbyDuplicate(nums []int, k int) bool {
    seen := make(map[int]int)
    for i, num := range nums {
        if prevIndex, found := seen[num]; found && i-prevIndex <= k {
            return true
        }
        seen[num] = i
    }
    return false
}

func main() {
    fmt.Println(containsNearbyDuplicate([]int{1, 2, 3, 1}, 3)) // Output: true
}
```

### Implementation in Java

```java
import java.util.HashMap;

class Solution {
    public boolean containsNearbyDuplicate(int[] nums, int k) {
        HashMap<Integer, Integer> seen = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if (seen.containsKey(nums[i]) && i - seen.get(nums[i]) <= k) {
                return true;
            }
            seen.put(nums[i], i);
        }
        return false;
    }
}
```

## Explanation

- We use a hash map to keep track of the last seen index of each element.
- If an element reappears within `k` indices, we return `true`.
- Otherwise, update the index and continue iterating.

## Time and Space Complexity

- **Time Complexity:** `O(n)`, since we traverse the array once.
- **Space Complexity:** `O(n)`, as we store up to `n` elements in the hash map.

## Conclusion

This approach efficiently checks for duplicate elements within a given index range using a hash map. ðŸš€

