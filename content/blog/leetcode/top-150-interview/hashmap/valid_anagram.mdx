---
title: Valid Anagram
description: Implementation of the Valid Anagram algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

### Example:

**Input:**

```
s = "anagram", t = "nagaram"
```

**Output:**

```
true
```

**Input:**

```
s = "rat", t = "car"
```

**Output:**

```
false
```

## Approach

1. Use an array of size `26` to count letter frequencies.
2. Iterate through `s` and `t` to update counts.
3. If all counts are zero, return `true`.
4. Otherwise, return `false`.

## Algorithm

1. If the lengths of `s` and `t` do not match, return `false`.
2. Create an integer array `count[26]`.
3. Iterate through `s` and `t`:
   - Increment `count` for each character in `s`.
   - Decrement `count` for each character in `t`.
4. If all elements in `count` are `0`, return `true`; otherwise, return `false`.

## Implementations

### Implementation in Go

```go
package main

import "fmt"

func isAnagram(s string, t string) bool {
    if len(s) != len(t) {
        return false
    }
    
    count := make([]int, 26)
    for i := 0; i < len(s); i++ {
        count[s[i]-'a']++
        count[t[i]-'a']--
    }
    
    for _, c := range count {
        if c != 0 {
            return false
        }
    }
    
    return true
}

func main() {
    fmt.Println(isAnagram("anagram", "nagaram")) // true
    fmt.Println(isAnagram("rat", "car"))         // false
}
```

### Implementation in Java

```java
import java.util.Arrays;

class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) return false;

        int[] count = new int[26];
        for (int i = 0; i < s.length(); i++) {
            count[s.charAt(i) - 'a']++;
            count[t.charAt(i) - 'a']--;
        }
        
        for (int c : count) {
            if (c != 0) return false;
        }
        return true;
    }
}
```

## Explanation

- Use an array to store character frequencies.
- If `s` and `t` have the same character counts, return `true`.
- Otherwise, return `false`.

## Time and Space Complexity

- **Time Complexity:** `O(n)`, where `n` is the length of `s`.
- **Space Complexity:** `O(1)`, since we use a fixed array of size `26`.

## Conclusion

This approach efficiently determines if two strings are anagrams using an array-based frequency counter. ðŸš€

