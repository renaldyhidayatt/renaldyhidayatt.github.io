---
title: Happy Number
description: Implementation of the Happy Number algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Write an algorithm to determine if a number `n` is happy.

A **happy number** is a number defined by the following process:

1. Starting with any positive integer, replace the number by the sum of the squares of its digits.
2. Repeat the process until the number equals `1` (where it will stay), or it loops endlessly in a cycle which does not include `1`.
3. Those numbers for which this process ends in `1` are happy numbers.

### Example:

**Input:**

```
n = 19
```

**Output:**

```
true
```

**Explanation:**

```
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```

## Approach

1. Use a set to track numbers already seen.
2. Repeatedly replace the number with the sum of the squares of its digits.
3. If we reach `1`, return `true`.
4. If we encounter a repeated number, return `false` (cycle detected).

## Algorithm

1. Create a helper function to calculate the sum of the squares of digits.
2. Use a set to keep track of seen numbers.
3. Iterate until `n` becomes `1` or we detect a cycle.

## Implementations

### Implementation in Go

```go
package main

import "fmt"

func isHappy(n int) bool {
    seen := make(map[int]bool)
    for n != 1 && !seen[n] {
        seen[n] = true
        n = sumOfSquares(n)
    }
    return n == 1
}

func sumOfSquares(n int) int {
    sum := 0
    for n > 0 {
        digit := n % 10
        sum += digit * digit
        n /= 10
    }
    return sum
}

func main() {
    fmt.Println(isHappy(19)) // Output: true
}
```

### Implementation in Java

```java
import java.util.HashSet;

class Solution {
    public boolean isHappy(int n) {
        HashSet<Integer> seen = new HashSet<>();
        while (n != 1 && !seen.contains(n)) {
            seen.add(n);
            n = sumOfSquares(n);
        }
        return n == 1;
    }
    
    private int sumOfSquares(int n) {
        int sum = 0;
        while (n > 0) {
            int digit = n % 10;
            sum += digit * digit;
            n /= 10;
        }
        return sum;
    }
}
```

## Explanation

- We use a set to detect cycles.
- We repeatedly replace the number with the sum of squares of its digits.
- If we reach `1`, we return `true`; otherwise, if we see a repeated number, return `false`.

## Time and Space Complexity

- **Time Complexity:** `O(log n)`, since the number of digits in `n` reduces over time.
- **Space Complexity:** `O(log n)`, as we store seen numbers in a set.

## Conclusion

This approach efficiently determines if a number is happy by leveraging hash sets to detect cycles. ðŸš€

