---
title: Two Sum
description: Solve the "Two Sum" problem efficiently using hash maps with implementations in Go, Java, TypeScript, and Python.
tags: ["leetcode", "golang", "java", "typescript", "python", "algorithms"]
date: "2024-09-28"
published: true
---

# Two Sum in Go

The "Two Sum" problem is a popular coding challenge often encountered in technical interviews. The task is simple: given an array of integers `nums` and a target integer, find two numbers in `nums` such that they add up to the target. You need to return their indices, and each problem has exactly one solution.

In this article, we will explore how to solve this problem efficiently using a **hash map** in Go, achieving a time complexity of **O(n)**.

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Using a Hash Map for O(n) Time Complexity](#using-a-hash-map-for-on-time-complexity)
4. [Algorithm](#algorithm)
5. [Flowchart](#flowchart)
6. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
   - [TypeScript](#implementation-in-typescript)
   - [Python](#implementation-in-python)
7. [Explanation](#explanation)
8. [Time and Space Complexity](#time-and-space-complexity)
9. [Conclusion](#conclusion)

## Problem Statement

You are given an array of integers `nums` and an integer `target`. The task is to return the indices of the two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you cannot use the same element twice.

### Example 1

```plaintext
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].
```

### Example 2

```plaintext
Input: nums = [3,2,4], target = 6
Output: [1,2]
```

### Example 3

```
Input: nums = [3,3], target = 6
Output: [0,1]
```

## Approach

### Using a Hash Map for O(n) Time Complexity

The brute force solution would involve a nested loop to check all pairs of numbers, leading to a time complexity of O(n²). However, we can improve this to O(n) using a hash map (or dictionary).

### Algorithm

1. Initialize a map: We use a hash map to store each number we encounter along with its index.
2. Iterate through the array: For each element nums[i], calculate the complement as target - nums[i].
3. Check the map: If the complement is already in the map, we've found the two numbers that add up to the target.
4. Return the result: Once the solution is found, return the indices of the two numbers.

### Flowchart

![Flowchart of Two Sum Algorithm](/leetcode/two_sum.png)


### Implementation in Go

```go
package main

import "fmt"

func TwoSum(nums []int, target int) []int {
    m := make(map[int]int) // Initialize the map

    for i := 0; i < len(nums); i++ {
        another := target - nums[i] // Calculate the complement

        // Check if the complement exists in the map
        if idx, ok := m[another]; ok {
            return []int{idx, i} // Return the two indices
        }

        m[nums[i]] = i // Store the current number and its index in the map
    }

    return nil // This line won't be reached as per the problem constraints
}

func main() {
    nums := []int{2, 7, 11, 15}
    target := 9
    result := TwoSum(nums, target)
    fmt.Println(result) // Output: [0, 1]
}
```

### Implementation in Java

```java
import java.util.HashMap;
import java.util.Map;

public class TwoSum {
    public static int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>(); // Initialize the map

        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i]; // Calculate the complement

            // Check if the complement exists in the map
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i }; // Return the two indices
            }

            map.put(nums[i], i); // Store the current number and its index in the map
        }

        throw new IllegalArgumentException("No two sum solution"); // This line won't be reached as per the problem constraints
    }

    public static void main(String[] args) {
        int[] nums = {2, 7, 11, 15};
        int target = 9;

        int[] result = twoSum(nums, target);
        System.out.println("[" + result[0] + ", " + result[1] + "]"); // Output: [0, 1]
    }
}
```

### Implementation In Typescript

```typescript
function twoSum(nums: number[], target: number): number[] {
  const map: Map<number, number> = new Map(); // Initialize the map

  for (let i = 0; i < nums.length; i++) {
    const complement = target - nums[i]; // Calculate the complement

    // Check if the complement exists in the map
    if (map.has(complement)) {
      return [map.get(complement) as number, i]; // Return the two indices
    }

    map.set(nums[i], i); // Store the current number and its index in the map
  }

  throw new Error("No two sum solution"); // This line won't be reached as per the problem constraints
}

// Example usage
const nums: number[] = [2, 7, 11, 15];
const target: number = 9;

const result: number[] = twoSum(nums, target);
console.log(result); // Output: [0, 1]
```

### Implementation In Python

```python
class Solution:
    def twoSum(self, nums: list[int], target: int) -> list[int]:
        # Initialize a dictionary to store numbers and their indices
        num_map = {}

        # Iterate through the list with indices
        for i, num in enumerate(nums):
            # Calculate the complement
            complement = target - num

            # Check if the complement exists in the map
            if complement in num_map:
                return [num_map[complement], i]  # Return the two indices

            # Store the current number and its index in the map
            num_map[num] = i

        return []  # Return an empty list if no solution is found
```


### Explanation

- We initialize a map m where the key is the number and the value is its index.
- For each element in nums, we compute the complement (target - nums[i]).
  If the complement is found in the map, we return the indices of the two numbers.
- If the complement is not found, we store the current number and its index in the map for future lookup.

### Time and Space Complexity

- Time Complexity: O(n) – We only pass through the array once.
- Space Complexity: O(n) – In the worst case, we store all the numbers in the hash map.

## Conclusion

Using a hash map allows us to solve the Two Sum problem in linear time, making it an efficient solution for large inputs. This approach is optimal and widely used in coding interviews.

```plaintext
Input: nums = [3,2,4], target = 6
Output: [1,2]
```
