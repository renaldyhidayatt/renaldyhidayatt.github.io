---
title: Is Subsequence
description: Implementation of the Is Subsequence algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given two strings `s` and `t`, return `true` if `s` is a subsequence of `t`, or `false` otherwise.

A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec" is not).

### Example:

**Input:**
```
s = "abc", t = "ahbgdc"
```
**Output:**
```
true
```

**Input:**
```
s = "axc", t = "ahbgdc"
```
**Output:**
```
false
```

## Approach

1. Use two pointers, one for `s` and one for `t`.
2. Traverse `t`, and if a character in `t` matches the current character in `s`, move the pointer in `s`.
3. If the pointer in `s` reaches the end of `s`, return `true`, else return `false`.

## Algorithm

1. Initialize two pointers `i = 0` and `j = 0`.
2. Iterate through `t`:
   - If `s[i] == t[j]`, increment `i`.
   - Always increment `j`.
3. If `i` reaches `len(s)`, return `true`, otherwise return `false`.

## Implementations

### Implementation in Go

```go
package main

import "fmt"

func isSubsequence(s string, t string) bool {
    i, j := 0, 0
    for j < len(t) {
        if i < len(s) && s[i] == t[j] {
            i++
        }
        j++
    }
    return i == len(s)
}

func main() {
    s := "abc"
    t := "ahbgdc"
    fmt.Println(isSubsequence(s, t))
}
```

### Implementation in Java

```java
class Solution {
    public boolean isSubsequence(String s, String t) {
        int i = 0, j = 0;
        while (j < t.length()) {
            if (i < s.length() && s.charAt(i) == t.charAt(j)) {
                i++;
            }
            j++;
        }
        return i == s.length();
    }
}
```

## Explanation

- The two-pointer approach efficiently checks if `s` appears in `t` in order.
- If we can match all characters of `s` in `t`, then `s` is a subsequence of `t`.

## Time and Space Complexity

- **Time Complexity:** `O(n)`, where `n` is the length of `t`.
- **Space Complexity:** `O(1)`, as we use only constant extra space.

## Conclusion

This solution is efficient and handles large inputs optimally. ðŸš€

