---
title: "Factorial Trailing Zeroes"
description: "Implementation of the Factorial Trailing Zeroes algorithm in Go and Java."
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
5. [Explanation](#explanation)
6. [Time and Space Complexity](#time-and-space-complexity)
7. [Conclusion](#conclusion)

## Problem Statement

The **Factorial Trailing Zeroes** problem requires determining the number of trailing zeroes in `n!` (n factorial).

### Example:

```
Input: n = 3
Output: 0
Explanation: 3! = 6, no trailing zero.
```

```
Input: n = 5
Output: 1
Explanation: 5! = 120, one trailing zero.
```

```
Input: n = 0
Output: 0
```

### Constraints:

- `0 <= n <= 10^4`

## Approach

- A trailing zero is created by factors of `10`, which is `2 * 5`.
- Every even number provides factors of `2`, so we only need to count factors of `5`.
- Count the number of times `n` is divisible by `5`, `25`, `125`, etc.
- Sum these counts to get the number of trailing zeroes.

## Algorithm

1. Initialize `count = 0`.
2. While `n >= 5`, divide `n` by `5` and add the quotient to `count`.
3. Return `count`.

## Implementations

### Implementation in Go

```go
package main

import (
    "fmt"
)

func trailingZeroes(n int) int {
    count := 0
    for n >= 5 {
        n /= 5
        count += n
    }
    return count
}

func main() {
    fmt.Println(trailingZeroes(3))  // Output: 0
    fmt.Println(trailingZeroes(5))  // Output: 1
    fmt.Println(trailingZeroes(10)) // Output: 2
}
```

### Implementation in Java

```java
class Solution {
    public int trailingZeroes(int n) {
        int count = 0;
        while (n >= 5) {
            n /= 5;
            count += n;
        }
        return count;
    }
}
```

## Explanation

- **Counting Factors of 5:** Since `2` is more frequent than `5` in factors, count occurrences of `5`.
- **Handling Large Numbers:** By iterating through multiples of `5`, `25`, etc., we efficiently count all factors of `5`.

## Time and Space Complexity

- **Time Complexity**: `O(log n)`, since we divide `n` by `5` iteratively.
- **Space Complexity**: `O(1)`, as we use only a few integer variables.

## Conclusion

This approach efficiently calculates the number of trailing zeroes in a factorial using logarithmic time complexity.
