---
title: "Same Tree"
description: "Implementation of the Same Tree algorithm in Go and Java."
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
5. [Explanation](#explanation)
6. [Time and Space Complexity](#time-and-space-complexity)
7. [Conclusion](#conclusion)

## Problem Statement

Given the roots of two binary trees `p` and `q`, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

### Example 1:

```
Input: p = [1,2,3], q = [1,2,3]
Output: true
```

### Example 2:

```
Input: p = [1,2], q = [1,null,2]
Output: false
```

### Example 3:

```
Input: p = [1,2,1], q = [1,1,2]
Output: false
```

### Constraints:

- The number of nodes in both trees is in the range [0, 100].
- `-10^4 <= Node.val <= 10^4`

## Approach

We use a recursive approach to compare the two binary trees. We check the following conditions:

1. If both trees are `nil`, return `true`.
2. If one of them is `nil` and the other is not, return `false`.
3. If the values of the nodes are different, return `false`.
4. Recursively check the left and right subtrees.

## Algorithm

1. Base case: If both nodes are `nil`, return `true`.
2. If one of them is `nil` or their values are different, return `false`.
3. Recursively check `left` and `right` children.

## Implementations

### Implementation in Go

```go
package main

import "fmt"

// TreeNode defines a binary tree node.
type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

// isSameTree checks if two binary trees are the same.
func isSameTree(p *TreeNode, q *TreeNode) bool {
	if p == nil && q == nil {
		return true
	}
	if p == nil || q == nil {
		return false
	}
	if p.Val != q.Val {
		return false
	}
	return isSameTree(p.Left, q.Left) && isSameTree(p.Right, q.Right)
}

func main() {
	// Example test case
	p := &TreeNode{1, &TreeNode{2, nil, nil}, &TreeNode{3, nil, nil}}
	q := &TreeNode{1, &TreeNode{2, nil, nil}, &TreeNode{3, nil, nil}}

	fmt.Println(isSameTree(p, q)) // Output: true
}
```

### Implementation in Java

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;
    TreeNode(int x) { val = x; }
}

public class SameTree {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if (p == null && q == null) return true;
        if (p == null || q == null) return false;
        if (p.val != q.val) return false;
        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
    }

    public static void main(String[] args) {
        TreeNode p = new TreeNode(1);
        p.left = new TreeNode(2);
        p.right = new TreeNode(3);

        TreeNode q = new TreeNode(1);
        q.left = new TreeNode(2);
        q.right = new TreeNode(3);

        SameTree solution = new SameTree();
        System.out.println(solution.isSameTree(p, q)); // Output: true
    }
}
```

## Explanation

- The function recursively checks each node in both trees.
- If the structure or values differ at any node, the function returns `false`.
- Otherwise, it continues checking the left and right subtrees.

## Time and Space Complexity

- **Time Complexity:** `O(N)`, where `N` is the number of nodes in the tree.
- **Space Complexity:** `O(H)`, where `H` is the height of the tree due to recursive stack calls.

## Conclusion

This problem demonstrates a fundamental tree traversal pattern using recursion. The solution is efficient, leveraging a direct comparison strategy to determine if two trees are identical.
