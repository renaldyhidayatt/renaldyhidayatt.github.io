---
title: Remove Duplicates from Sorted List II
description: Implementation of the Remove Duplicates from Sorted List II algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.

### Example:

**Input:**

```
head = [1,2,3,3,4,4,5]
```

**Output:**

```
[1,2,5]
```

## Approach

1. Use a dummy node to handle edge cases.
2. Traverse the list while tracking duplicates.
3. Remove nodes that have duplicates.
4. Maintain a pointer to reconnect distinct elements.

## Algorithm

1. Create a dummy node before `head`.
2. Use a pointer to iterate through the list and detect duplicates.
3. Remove consecutive duplicate nodes.
4. Return the modified list.

## Implementations

### Implementation in Go

```go
package main

type ListNode struct {
    Val  int
    Next *ListNode
}

func deleteDuplicates(head *ListNode) *ListNode {
    dummy := &ListNode{Next: head}
    prev := dummy
    
    for head != nil {
        if head.Next != nil && head.Val == head.Next.Val {
            for head.Next != nil && head.Val == head.Next.Val {
                head = head.Next
            }
            prev.Next = head.Next
        } else {
            prev = prev.Next
        }
        head = head.Next
    }
    
    return dummy.Next
}
```

### Implementation in Java

```java
class ListNode {
    int val;
    ListNode next;
    ListNode(int val) { this.val = val; this.next = null; }
}

class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode prev = dummy;
        
        while (head != null) {
            if (head.next != null && head.val == head.next.val) {
                while (head.next != null && head.val == head.next.val) {
                    head = head.next;
                }
                prev.next = head.next;
            } else {
                prev = prev.next;
            }
            head = head.next;
        }
        
        return dummy.next;
    }
}
```

## Explanation

- We use a dummy node to handle cases where the first node might be removed.
- The traversal ensures only distinct nodes remain in the list.
- By skipping duplicate values, we maintain the list order.

## Time and Space Complexity

- **Time Complexity:** `O(n)`, where `n` is the number of nodes in the list.
- **Space Complexity:** `O(1)`, as we use only a few pointers.

## Conclusion

This approach efficiently removes duplicates from a sorted linked list while maintaining `O(1)` extra space usage. ðŸš€

