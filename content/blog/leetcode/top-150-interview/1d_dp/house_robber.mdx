---
title: House Robber
description: Implementation of the House Robber algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-02"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given an integer array `nums` representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.

### Examples

**Example 1:**

```
Input: nums = [1,2,3,1]
Output: 4
```

**Example 2:**

```
Input: nums = [2,7,9,3,1]
Output: 12
```

### Constraints:

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 400`

## Approach

We can solve this problem using **Dynamic Programming (DP)**.

## Implementation in Go

```go
func rob(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    if len(nums) == 1 {
        return nums[0]
    }
    
    dp := make([]int, len(nums))
    dp[0], dp[1] = nums[0], max(nums[0], nums[1])
    
    for i := 2; i < len(nums); i++ {
        dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    }
    
    return dp[len(nums)-1]
}

func max(a, b int) int {
    if a > b {
        return a
    }
    return b
}
```

## Implementation in Java

```java
class Solution {
    public int rob(int[] nums) {
        if (nums.length == 0) return 0;
        if (nums.length == 1) return nums[0];
        
        int[] dp = new int[nums.length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        
        for (int i = 2; i < nums.length; i++) {
            dp[i] = Math.max(dp[i-1], dp[i-2] + nums[i]);
        }
        
        return dp[nums.length - 1];
    }
}
```

## Explanation

1. **Iterative DP Approach**: We maintain an array `dp` where `dp[i]` represents the maximum amount of money that can be robbed up to house `i`.
2. **Transition Formula**: `dp[i] = max(dp[i-1], dp[i-2] + nums[i])`.
3. **Final Result**: The maximum money that can be robbed is stored in `dp[n-1]`.

## Time and Space Complexity

- **Time Complexity**: `O(n)`, as we iterate through the array once.
- **Space Complexity**: `O(n)`, as we use an extra array `dp`.

## Conclusion

Using **Dynamic Programming**, we efficiently compute the maximum amount of money that can be robbed without alerting the police.

