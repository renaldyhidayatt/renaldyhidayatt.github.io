---
title: H-Index
description: Implementation of the H-Index algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given an array of integers `citations` where `citations[i]` is the number of citations a researcher received for their `i-th` paper, return the researcher's **h-index**.

The **h-index** is defined as the maximum value `h` such that the given researcher has published at least `h` papers that have each been cited at least `h` times.

### Example 1:

**Input:**
```
citations = [3,0,6,1,5]
```
**Output:**
```
3
```

### Example 2:

**Input:**
```
citations = [1,3,1]
```
**Output:**
```
1
```

## Approach

- **Sorting Approach:**
  - Sort the array in descending order.
  - Find the maximum `h` such that `citations[h] >= h+1`.

## Algorithm

1. Sort the citations array in descending order.
2. Iterate over the array to find the maximum h-index.
3. Return the maximum valid h-index.

## Implementations

### Implementation in Go

```go
package main
import (
    "fmt"
    "sort"
)

func hIndex(citations []int) int {
    sort.Sort(sort.Reverse(sort.IntSlice(citations)))
    h := 0
    for i, c := range citations {
        if c >= i+1 {
            h = i + 1
        } else {
            break
        }
    }
    return h
}

func main() {
    citations := []int{3, 0, 6, 1, 5}
    fmt.Println(hIndex(citations)) // Output: 3
}
```

### Implementation in Java

```java
import java.util.Arrays;
import java.util.Collections;

class HIndex {
    public int hIndex(int[] citations) {
        Arrays.sort(citations);
        int h = 0, n = citations.length;
        for (int i = 0; i < n; i++) {
            if (citations[n - 1 - i] >= i + 1) {
                h = i + 1;
            } else {
                break;
            }
        }
        return h;
    }

    public static void main(String[] args) {
        HIndex hIndexCalc = new HIndex();
        int[] citations = {3, 0, 6, 1, 5};
        System.out.println(hIndexCalc.hIndex(citations)); // Output: 3
    }
}
```

## Explanation

- **Sorting Approach:** Sorting allows us to efficiently determine the maximum `h`.
- **Greedy Selection:** We iterate through the sorted list to determine the maximum valid h-index.

## Time and Space Complexity

- **Time Complexity:** `O(n log n)`, due to sorting.
- **Space Complexity:** `O(1)`, since we sort in-place.

## Conclusion

The **H-Index** problem can be efficiently solved using sorting and iteration, achieving an `O(n log n)` time complexity and `O(1)` space complexity. ðŸš€

