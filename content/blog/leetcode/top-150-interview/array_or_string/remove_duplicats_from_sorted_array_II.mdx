---
title: Remove Duplicates from Sorted Array II
description: Implementation of the Remove Duplicates from Sorted Array II algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-03"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

Given an integer array `nums` sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most **twice**. The relative order of the elements should be kept the same.

### Example 1:

**Input:**
```
nums = [1,1,1,2,2,3]
```
**Output:**
```
5, nums = [1,1,2,2,3,_]
```

### Example 2:

**Input:**
```
nums = [0,0,1,1,1,1,2,3,3]
```
**Output:**
```
7, nums = [0,0,1,1,2,3,3,_,_]
```

## Approach

- **Two Pointers:**
  - One pointer (`j`) tracks the position where the next allowed duplicate should be placed.
  - Another pointer (`i`) iterates through the array.
  - Keep a count of occurrences to ensure at most **two** duplicates are retained.

## Algorithm

1. Initialize `j = 0` and `count = 1`.
2. Iterate over `nums` starting from index 1:
   - If `nums[i] == nums[j]`, increment `count`.
   - If `count <= 2`, update `nums[j+1]` and increment `j`.
   - If `nums[i]` is different from `nums[j]`, reset `count` to 1 and update `nums[j+1]`.
3. Return `j + 1`.

## Implementations

### Implementation in Go

```go
package main
import "fmt"

func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    j, count := 0, 1
    for i := 1; i < len(nums); i++ {
        if nums[i] == nums[j] {
            count++
        } else {
            count = 1
        }
        if count <= 2 {
            j++
            nums[j] = nums[i]
        }
    }
    return j + 1
}

func main() {
    nums := []int{0,0,1,1,1,1,2,3,3}
    k := removeDuplicates(nums)
    fmt.Println(k, nums[:k]) // Output: 7, [0,0,1,1,2,3,3]
}
```

### Implementation in Java

```java
import java.util.*;

class RemoveDuplicatesII {
    public int removeDuplicates(int[] nums) {
        if (nums.length == 0) return 0;
        int j = 0, count = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[j]) {
                count++;
            } else {
                count = 1;
            }
            if (count <= 2) {
                j++;
                nums[j] = nums[i];
            }
        }
        return j + 1;
    }

    public static void main(String[] args) {
        RemoveDuplicatesII rd = new RemoveDuplicatesII();
        int[] nums = {0,0,1,1,1,1,2,3,3};
        int k = rd.removeDuplicates(nums);
        System.out.println(k + ", " + Arrays.toString(Arrays.copyOf(nums, k))); // Output: 7, [0,0,1,1,2,3,3]
    }
}
```

## Explanation

- **Two-Pointer Approach:** Ensures `O(n)` time complexity.
- **In-place modification:** Uses `O(1)` space.

## Time and Space Complexity

- **Time Complexity:** `O(n)`, as we iterate through the array once.
- **Space Complexity:** `O(1)`, since we do not use extra space.

## Conclusion

The **Remove Duplicates from Sorted Array II** problem can be efficiently solved using a **Two-Pointer Approach**, achieving `O(n)` time complexity and `O(1)` space complexity. ðŸš€

