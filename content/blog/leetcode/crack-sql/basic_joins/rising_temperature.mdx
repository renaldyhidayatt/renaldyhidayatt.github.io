---
title: "Basic Joins in SQL"
description: "Introduction to fundamental SQL joins, including INNER JOIN, LEFT JOIN, RIGHT JOIN, and FULL JOIN, with examples and use cases."
tags: ["SQL", "joins", "INNER JOIN", "LEFT JOIN", "RIGHT JOIN", "FULL JOIN", "database"]
date: "2025-03-03"
published: false
---


## 197. Rising Temperature


## Problem Statement

The goal of this problem is to find all the dates where the recorded temperature was higher than the previous day's temperature. You need to return the IDs of the rows corresponding to these dates.

### Input Table Structure

#### Weather Table

The `Weather` table contains the following columns:

- **`id`**: A unique identifier for each record (Primary Key).
- **`recordDate`**: The date of the temperature record.
- **`temperature`**: The temperature recorded on that date.

### Example Input

```table
| id | recordDate | temperature |
|----|------------|-------------|
| 1  | 2015-01-01 | 10          |
| 2  | 2015-01-02 | 25          |
| 3  | 2015-01-03 | 20          |
| 4  | 2015-01-04 | 30          |

```

### Example Ouput

```table
| id |
|----|
| 2  |
| 4  |
```

### Explanation:
- On 2015-01-02, the temperature (25) was higher than the previous day (2015-01-01: 10).
- On 2015-01-04, the temperature (30) was higher than the previous day (2015-01-03: 20).
No other dates meet the criteria.


### SQL Implementation
In SQL, you can use self-join to compare the temperature of a date with the temperature of the previous day.


### SQL Query

```sql
SELECT w1.id
FROM Weather w1
JOIN Weather w2
ON DATE_ADD(w2.recordDate, INTERVAL 1 DAY) = w1.recordDate
WHERE w1.temperature > w2.temperature;
```


### Explanation:
- Self-Join (JOIN): Join the Weather table with itself. The condition ensures that w2.recordDate is one day before w1.recordDate.
- Comparison (WHERE): Filter records where the temperature on w1 is higher than the temperature on w2.
- Select: Return the IDs of the rows (w1.id) where the condition is met.

### NoSQL (MongoDB) Implementation
In MongoDB, you can use the aggregation framework to achieve the same result by sorting and grouping the data, then using $expr for comparisons.

### MongoDB Query

```js
db.weather.aggregate([
  {
    $sort: { recordDate: 1 }
  },
  {
    $lookup: {
      from: "weather",
      let: { currentDate: "$recordDate", currentTemp: "$temperature" },
      pipeline: [
        {
          $match: {
            $expr: {
              $eq: ["$recordDate", { $dateSubtract: { startDate: "$$currentDate", unit: "day", amount: 1 } }]
            }
          }
        }
      ],
      as: "previousDay"
    }
  },
  {
    $unwind: "$previousDay"
  },
  {
    $match: {
      $expr: {
        $gt: ["$temperature", "$previousDay.temperature"]
      }
    }
  },
  {
    $project: {
      id: 1,
      _id: 0
    }
  }
]);
```

### Explanation:
- ``$sort``: Sort the documents by recordDate in ascending order to ensure proper processing.
- ``$lookup``: Perform a self-join where each document looks for the record of the previous day by subtracting one day from its recordDate.
- ``$unwind``: Flatten the array resulting from the $lookup stage.
- ``$match``: Filter records where the current day's temperature is higher than the previous day's temperature.
- ``$project``: Output only the id field of the matched documents.

---------------------------