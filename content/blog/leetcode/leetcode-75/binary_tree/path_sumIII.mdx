---
title: Path Sum III
description: Count the number of paths in a binary tree that sum to a given target. Includes Go and Java implementations.
tags: ["leetcode-75", "golang", "java", "algorithms", "interview", "python", "leetcode"]
date: "2025-03-02"
published: true
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
   - [Python](#implementation-in-python)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement
The path does not need to start or end at the root or a leaf, but it must go downwards (i.e., traveling only from parent nodes to child nodes).

**Examples:**

**Example 1:**
```
Input: root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8
Output: 3
```

**Example 2:**
```
Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
Output: 3
```

### Constraints:

- The number of nodes in the tree is in the range `[0, 1000]`.
- `-10^9 <= Node.val <= 10^9`
- `-1000 <= targetSum <= 1000`

### Implementation in Go

```go
type TreeNode struct {
    Val   int
    Left  *TreeNode
    Right *TreeNode
}

func pathSumHelper(root *TreeNode, targetSum int, currentSum int, prefixSum map[int]int) int {
    if root == nil {
        return 0
    }
    currentSum += root.Val
    count := prefixSum[currentSum-targetSum]
    prefixSum[currentSum]++
    count += pathSumHelper(root.Left, targetSum, currentSum, prefixSum)
    count += pathSumHelper(root.Right, targetSum, currentSum, prefixSum)
    prefixSum[currentSum]--
    return count
}

func pathSum(root *TreeNode, targetSum int) int {
    prefixSum := make(map[int]int)
    prefixSum[0] = 1
    return pathSumHelper(root, targetSum, 0, prefixSum)
}
```

### Implementation in Java

```java
import java.util.HashMap;

class TreeNode {
    int val;
    TreeNode left, right;
    TreeNode(int val) { this.val = val; }
}

class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        HashMap<Integer, Integer> prefixSum = new HashMap<>();
        prefixSum.put(0, 1);
        return pathSumHelper(root, targetSum, 0, prefixSum);
    }
    
    private int pathSumHelper(TreeNode node, int targetSum, int currentSum, HashMap<Integer, Integer> prefixSum) {
        if (node == null) return 0;
        currentSum += node.val;
        int count = prefixSum.getOrDefault(currentSum - targetSum, 0);
        prefixSum.put(currentSum, prefixSum.getOrDefault(currentSum, 0) + 1);
        count += pathSumHelper(node.left, targetSum, currentSum, prefixSum);
        count += pathSumHelper(node.right, targetSum, currentSum, prefixSum);
        prefixSum.put(currentSum, prefixSum.get(currentSum) - 1);
        return count;
    }
}
```

### Implementation in Python

```python
class TreeNode:
    def __init__(self, val=0, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right

class Solution:
    def pathSumHelper(self, root: TreeNode, targetSum: int, currentSum: int, prefixSum: dict) -> int:
        if root is None:
            return 0
        
        currentSum += root.val
        count = prefixSum.get(currentSum - targetSum, 0)
        
        # Update the prefixSum map with the current sum
        prefixSum[currentSum] = prefixSum.get(currentSum, 0) + 1
        
        # Recur on left and right subtrees
        count += self.pathSumHelper(root.left, targetSum, currentSum, prefixSum)
        count += self.pathSumHelper(root.right, targetSum, currentSum, prefixSum)
        
        # Backtrack: revert the current sum for the current path
        prefixSum[currentSum] -= 1
        
        return count
    
    def pathSum(self, root: TreeNode, targetSum: int) -> int:
        prefixSum = {0: 1}  # Initialize the prefixSum map with 0 having one occurrence
        return self.pathSumHelper(root, targetSum, 0, prefixSum)
```

## Conclusion

This approach efficiently counts the number of paths in a binary tree that sum to a given target using a prefix sum technique. The time complexity is `O(n)`, where `n` is the number of nodes, and the space complexity is `O(n)` due to the hashmap storage.

