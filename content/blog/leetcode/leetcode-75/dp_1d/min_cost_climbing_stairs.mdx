---
title: Min Cost Climbing Stairs
description: Implementation of the Min Cost Climbing Stairs algorithm with Go and Java.
tags: ["leetcode", "golang", "java", "algorithms"]
date: "2025-03-02"
published: false
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement


You are given an integer array `cost` where `cost[i]` is the cost of `i`-th step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index `0`, or the step with index `1`.

Return the minimum cost to reach the top of the floor.

### Examples

**Example 1:**

```
Input: cost = [10,15,20]
Output: 15
```

**Example 2:**

```
Input: cost = [1,100,1,1,1,100,1,1,100,1]
Output: 6
```

### Constraints:

- `2 <= cost.length <= 1000`
- `0 <= cost[i] <= 999`

## Approach

We can solve this problem using **Dynamic Programming (DP)**.

## Implementation in Go

```go
func minCostClimbingStairs(cost []int) int {
    n := len(cost)
    dp := make([]int, n+1)
    
    for i := 2; i <= n; i++ {
        dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])
    }
    return dp[n]
}

func min(a, b int) int {
    if a < b {
        return a
    }
    return b
}
```

## Implementation in Java

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[n+1];
        
        for (int i = 2; i <= n; i++) {
            dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2]);
        }
        return dp[n];
    }
}
```

## Explanation

1. **Iterative DP Approach**: We maintain an array `dp` where `dp[i]` represents the minimum cost to reach step `i`.
2. **Transition Formula**: `dp[i] = min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])`.
3. **Final Result**: The minimum cost to reach the top is stored in `dp[n]`.

## Time and Space Complexity

- **Time Complexity**: `O(n)`, as we iterate through the array once.
- **Space Complexity**: `O(n)`, as we use an extra array `dp`.

## Conclusion

Using **Dynamic Programming**, we efficiently compute the minimum cost to climb the stairs with optimal performance.

