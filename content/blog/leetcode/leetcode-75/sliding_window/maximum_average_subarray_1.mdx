---
title: Maximum Average Subarray I
description: Find the contiguous subarray of length k with the maximum average value. Includes Go and Java implementations.
tags: ["leetcode-75", "golang", "java", "algorithms", "interview", "python", "leetcode"]
date: "2025-03-02"
published: true
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
   - [Python](#implementation-in-python)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement

You are given an integer array nums consisting of n elements, and an integer k.

Find a contiguous subarray whose length is equal to k that has the maximum average value and return this value. Any answer with a calculation error less than 10^-5 will be accepted.

### Example 1:

**Input:** nums = [1,12,-5,-6,50,3], k = 4  
**Output:** 12.75000  
**Explanation:** Maximum average is (12 - 5 - 6 + 50) / 4 = 51 / 4 = 12.75  

### Example 2:

**Input:** nums = [5], k = 1  
**Output:** 5.00000  

### Constraints:

- n == nums.length
- 1 <= k <= n <= 10^5
- -10^4 <= nums[i] <= 10^4

## Approach

We use the sliding window technique to efficiently find the maximum average subarray of length k.

## Algorithm

1. Compute the sum of the first k elements.
2. Slide the window across the array, updating the sum by subtracting the leftmost element and adding the next element.
3. Keep track of the maximum sum found.
4. Return the maximum sum divided by k.

## Flowchart

```plantuml
@startuml
start
:Initialize maxSum with sum of first k elements;
:Initialize currentSum with maxSum;

while (i < n - k) do
    :Update currentSum by subtracting nums[i] and adding nums[i + k];
    :Update maxSum if currentSum is greater;
    i = i + 1;
endwhile

:Return maxSum / k;
stop
@enduml
```

## Implementations

### Implementation in Go

```go
func findMaxAverage(nums []int, k int) float64 {
    sum := 0
    for i := 0; i < k; i++ {
        sum += nums[i]
    }
    maxSum := sum
    for i := k; i < len(nums); i++ {
        sum += nums[i] - nums[i-k]
        if sum > maxSum {
            maxSum = sum
        }
    }
    return float64(maxSum) / float64(k)
}
```

### Implementation in Java

```java
public class Solution {
    public double findMaxAverage(int[] nums, int k) {
        int sum = 0;
        for (int i = 0; i < k; i++) {
            sum += nums[i];
        }
        int maxSum = sum;
        for (int i = k; i < nums.length; i++) {
            sum += nums[i] - nums[i - k];
            maxSum = Math.max(maxSum, sum);
        }
        return (double) maxSum / k;
    }
}
```

### Implementation in Python
```python
class Solution:
    def findMaxAverage(self, nums: list[int], k: int) -> float:
        total = sum(nums[:k])
        max_sum = total

        for i in range(k, len(nums)):
            total += nums[i] - nums[i - k]
            max_sum = max(max_sum, total)

        return max_sum / k
```


## Explanation

This approach efficiently finds the maximum average subarray in O(n) time using the sliding window technique, ensuring optimal performance.

## Time and Space Complexity

- **Time Complexity:** O(n) as we iterate through the list once.
- **Space Complexity:** O(1) since we only use a few extra variables.

## Conclusion

This solution effectively finds the maximum average subarray using a sliding window approach, maintaining efficiency while keeping memory usage minimal.

