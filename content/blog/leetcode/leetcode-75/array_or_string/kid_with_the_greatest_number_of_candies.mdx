---
title: "1431.Kids With the Greatest Number of Candies"
description: "Implementation of the Kids With the Greatest Number of Candies algorithm in Go and Java."
tags: ["leetcode-75", "golang", "java", "algorithms", "interview", "python", "leetcode"]
date: "2025-03-02"
published: true
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
   - [Python](#implementation-in-python)
5. [Explanation](#explanation)
6. [Time and Space Complexity](#time-and-space-complexity)
7. [Conclusion](#conclusion)

## Problem Statement

There are `n` kids with candies. You are given an integer array `candies`, where `candies[i]` represents the number of candies the `i`th kid has, and an integer `extraCandies`, denoting the number of extra candies that you have.

Return a boolean array `result` of length `n`, where `result[i]` is `true` if, after giving the `i`th kid all the `extraCandies`, they will have the greatest number of candies among all the kids, or `false` otherwise.

### Example

#### Input:
```plaintext
candies = [2,3,5,1,3], extraCandies = 3
```
#### Output:
```plaintext
[true,true,true,false,true]
```

#### Input:
```plaintext
candies = [4,2,1,1,2], extraCandies = 1
```
#### Output:
```plaintext
[true,false,false,false,false]
```

#### Input:
```plaintext
candies = [12,1,12], extraCandies = 10
```
#### Output:
```plaintext
[true,false,true]
```

### Constraints

- `2 <= n <= 100`
- `1 <= candies[i] <= 100`
- `1 <= extraCandies <= 50`

## Approach

- Find the **maximum number of candies** any kid currently has.
- Iterate through the `candies` array and check if adding `extraCandies` to each kid results in a value greater than or equal to the maximum found earlier.
- Store the result in a boolean array.

## Algorithm

1. Find the maximum value in the `candies` array.
2. Iterate through `candies` and check if `candies[i] + extraCandies >= maxCandies`.
3. Store `true` or `false` accordingly.

## Implementations

### Implementation in Go

```go
package main

import "fmt"

func kidsWithCandies(candies []int, extraCandies int) []bool {
    maxCandies := 0
    for _, c := range candies {
        if c > maxCandies {
            maxCandies = c
        }
    }
    
    result := make([]bool, len(candies))
    for i, c := range candies {
        result[i] = (c + extraCandies) >= maxCandies
    }
    return result
}
```

### Implementation in Java

```java
import java.util.*;

class Solution {
    public List<Boolean> kidsWithCandies(int[] candies, int extraCandies) {
        int maxCandies = 0;
        for (int c : candies) {
            maxCandies = Math.max(maxCandies, c);
        }
        
        List<Boolean> result = new ArrayList<>();
        for (int c : candies) {
            result.add(c + extraCandies >= maxCandies);
        }
        return result;
    }
}
```

### Implementation in Python

```python
from typing import List

class Solution:
    def kidsWithCandies(self, candies: List[int], extraCandies: int) -> List[bool]:
        max_candies = max(candies)
        result = []
        for c in candies:
            result.append((c + extraCandies) >= max_candies)
        return result
```

## Explanation

- The algorithm first finds the maximum candy count among the kids.
- Then, it iterates through the `candies` array and checks if adding `extraCandies` makes the current kid's candies at least equal to the maximum found earlier.
- The results are stored in a boolean list and returned.

## Time and Space Complexity

- **Time Complexity**: `O(n)`, as we traverse the array twice (once to find max, once to compare values).
- **Space Complexity**: `O(n)`, storing the results in a boolean list.

## Conclusion

This approach efficiently determines which kids can have the greatest number of candies with the given extra candies.
