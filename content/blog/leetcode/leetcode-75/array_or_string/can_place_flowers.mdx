---
title: "605.Can Place Flowers"
description: Determine if new flowers can be planted in a flowerbed without violating adjacency rules. Includes Go and Java implementations.
tags: ["leetcode-75", "golang", "java", "algorithms", "interview", "python", "leetcode"]
date: "2025-03-02"
published: true
---

## Table of Contents
1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
   - [Python](#implementation-in-python)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## 1. Problem Statement

You have a long flowerbed where some plots are planted (1) and some are empty (0). Flowers cannot be planted in adjacent plots.

Given an integer array `flowerbed` and an integer `n`, return `true` if `n` new flowers can be planted without violating the no-adjacent-flowers rule, otherwise return `false`.

### Example 1:

**Input:**
```plaintext
flowerbed = [1,0,0,0,1], n = 1
```
**Output:**
```plaintext
true
```

### Example 2:

**Input:**
```plaintext
flowerbed = [1,0,0,0,1], n = 2
```
**Output:**
```plaintext
false
```

### Constraints:

- `1 <= flowerbed.length <= 2 * 10^4`
- `flowerbed[i]` is `0` or `1`.
- No two adjacent plots have flowers initially.
- `0 <= n <= flowerbed.length`.

---

## 2. Approach

We iterate through the `flowerbed` array, checking if a plot and its adjacent plots are empty before placing a flower. We keep track of the count of flowers that can be planted and return `true` if it meets or exceeds `n`.

---

## 3. Algorithm

1. Initialize `count = 0` to keep track of placed flowers.
2. Iterate over `flowerbed`:
   - Check if the current plot and its adjacent plots (left and right) are empty.
   - If so, plant a flower (`flowerbed[i] = 1`) and increment `count`.
3. If `count >= n`, return `true`; otherwise, return `false`.

---

## 4. Flowchart

```plaintext
Start
   |
   v
Initialize count = 0
   |
   v
Loop through flowerbed
   |
   v
Check if current plot and adjacent plots are empty
   |
   v
If yes, plant a flower and increment count
   |
   v
Check if count >= n
   |
   v
Return true if count >= n, else return false
```

---

## 5. Implementations

### **Implementation in Go**

```go
func canPlaceFlowers(flowerbed []int, n int) bool {
    count := 0
    for i := 0; i < len(flowerbed); i++ {
        if flowerbed[i] == 0 && (i == 0 || flowerbed[i-1] == 0) && (i == len(flowerbed)-1 || flowerbed[i+1] == 0) {
            flowerbed[i] = 1
            count++
            if count >= n {
                return true
            }
        }
    }
    return count >= n
}
``` 

### **Implementation in Java**

```java
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int count = 0;
        for (int i = 0; i < flowerbed.length; i++) {
            if (flowerbed[i] == 0 && (i == 0 || flowerbed[i-1] == 0) && (i == flowerbed.length - 1 || flowerbed[i+1] == 0)) {
                flowerbed[i] = 1;
                count++;
                if (count >= n) {
                    return true;
                }
            }
        }
        return count >= n;
    }
}
```

### **Implementation in Python**
```python
from typing import List

def can_place_flowers(flowerbed: List[int], n: int) -> bool:
    count = 0
    for i in range(len(flowerbed)):
        if (flowerbed[i] == 0 and 
            (i == 0 or flowerbed[i - 1] == 0) and 
            (i == len(flowerbed) - 1 or flowerbed[i + 1] == 0)):
            flowerbed[i] = 1
            count += 1
            if count >= n:
                return True
    return count >= n
```

---

## 6. Explanation

This approach ensures that flowers are only placed where no adjacent flowers exist. It efficiently checks valid placements and updates the `flowerbed` array accordingly.

---

## 7. Time and Space Complexity

- **Time Complexity:** `O(f)`, where `f` is the length of the flowerbed array. Each element is checked once.
- **Space Complexity:** `O(1)`, as the algorithm modifies the input array in place without extra space.

---

## 8. Conclusion

This problem can be efficiently solved using a single pass over the flowerbed array. The approach ensures that no adjacent flowers violate the placement rule while maximizing the number of placed flowers.