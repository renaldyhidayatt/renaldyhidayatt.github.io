---
title: Single Number
description: Implementation of the Single Number algorithm in Go and Java.
tags: ["leetcode-75", "golang", "java", "algorithms", "interview", "python", "leetcode"]
date: "2025-03-02"
published: true
---

## Table of Contents

1. [Problem Statement](#problem-statement)
2. [Approach](#approach)
3. [Algorithm](#algorithm)
4. [Flowchart](#flowchart)
5. [Implementations](#implementations)
   - [Go](#implementation-in-go)
   - [Java](#implementation-in-java)
   - [Python](#implementation-in-python)
6. [Explanation](#explanation)
7. [Time and Space Complexity](#time-and-space-complexity)
8. [Conclusion](#conclusion)

## Problem Statement


Given a non-empty array of integers `nums`, every element appears twice except for one. Find that single one.

You must implement a solution with a linear runtime complexity and use only constant extra space.

### Examples

**Example 1:**

```
Input: nums = [2,2,1]
Output: 1
```

**Example 2:**

```
Input: nums = [4,1,2,1,2]
Output: 4
```

**Example 3:**

```
Input: nums = [1]
Output: 1
```

### Constraints:

- `1 <= nums.length <= 3 * 10^4`
- `-3 * 10^4 <= nums[i] <= 3 * 10^4`
- Each element in the array appears twice except for one element which appears only once.

## Approach

We can use **bitwise XOR** to find the single number in `O(n)` time and `O(1)` space.

### Implementation in Go

```go
func singleNumber(nums []int) int {
    result := 0
    for _, num := range nums {
        result ^= num
    }
    return result
}
```

### Implementation in Java

```java
class Solution {
    public int singleNumber(int[] nums) {
        int result = 0;
        for (int num : nums) {
            result ^= num;
        }
        return result;
    }
}
```

### Implementation in Python
```python
class Solution:
    def singleNumber(self, nums: list[int]) -> int:
        result = 0
        for num in nums:
            result ^= num
        return result
```


## Explanation

1. **Using XOR operation (`^`)**:
   - `x ^ x = 0` (same numbers cancel out)
   - `x ^ 0 = x` (0 has no effect)
   - Applying XOR to all elements results in the unique number since duplicates cancel each other.
2. **Final Result:** The remaining number is the one that appears only once.

## Time and Space Complexity

- **Time Complexity**: `O(n)`, as we iterate once over `nums`.
- **Space Complexity**: `O(1)`, as we use only a single variable.

## Conclusion

Using **bitwise XOR**, we efficiently find the unique element in an array where all other elements appear twice.

